/*** Generated by streamline 0.4.5 (callbacks) - DO NOT EDIT ***/ var __rt=require('streamline/lib/callbacks/runtime').runtime(__filename),__func=__rt.__func,__cb=__rt.__cb,__tryCatch=__rt.__tryCatch; var azure = require("azure");
















var http = require("http");
var BlobConstants = azure.Constants.BlobConstants;
var connectionStringParser = azure.ConnectionStringParser;
var flows = require("streamline/lib/util/flows");
var os = require("os");
var fs = require("fs");
var path = require("path");
var crypto = require("crypto");
var StorageServiceSettings = azure.StorageServiceSettings;
var util = require("util");
var utils = require("../util/utils.js");
var ExponentialRetryPolicyFilter = azure.ExponentialRetryPolicyFilter;




var cli = null;
var logger = null;
var progress = null;




var restFunnel = null;




var operationTimeout = null;




var StorageUtil = {};




StorageUtil.ENV_CONNECTIONSTRING_NAME = "AZURE_STORAGE_CONNECTION_STRING";
StorageUtil.ENV_SDK_ACCOUNT_NAME = "AZURE_STORAGE_ACCOUNT";
StorageUtil.ENV_SDK_ACCOUNT_KEY = "AZURE_STORAGE_ACCESS_KEY";
StorageUtil.CONCURRENTCY_CONFIG_KEY_NAME = "azure_storage_concurrency";
StorageUtil.OPERATION_TIMEOUT_CONFIG_KEY_NAME = "azure_storage_timeout";




StorageUtil.OperationType = {
  Blob: "blob",
  Queue: "queue",
  Table: "table"};





StorageUtil.init = function(azureCli) {
  cli = azureCli;
  logger = cli.output;
  var cfg = utils.readConfig();
  var restConcurrency = getRestConcurrency(cfg);
  http.globalAgent.maxSockets = restConcurrency;
  restFunnel = flows.funnel(restConcurrency);
  operationTimeout = getRestOperationTimeout(cfg);};








StorageUtil.StorageOperation = function(type, operation) {
  this.type = type;
  this.operation = operation;};







StorageUtil.getBlobService = function(connectionString) {
  var serviceSettings = getStorageServiceSettings(connectionString);
  var service = null;
  if ((serviceSettings === null)) {

    service = azure.createBlobService(); }
   else {
    service = azure.createBlobService(serviceSettings._name, serviceSettings._key, serviceSettings._blobEndpointUri); };

  return service.withFilter(new ExponentialRetryPolicyFilter());};







StorageUtil.getTableService = function(connectionString) {
  var serviceSettings = getStorageServiceSettings(connectionString);
  var service = null;
  if ((serviceSettings === null)) {

    service = azure.createTableService(); }
   else {
    service = azure.createTableService(serviceSettings._name, serviceSettings._key, serviceSettings._tableEndpointUri); };

  return service.withFilter(new ExponentialRetryPolicyFilter());};







StorageUtil.getQueueService = function(connectionString) {
  var serviceSettings = getStorageServiceSettings(connectionString);
  var service = null;
  if ((serviceSettings === null)) {

    service = azure.createQueueService(); }
   else {
    service = azure.createQueueService(serviceSettings._name, serviceSettings._key, serviceSettings._queueEndpointUri); };

  return service.withFilter(new ExponentialRetryPolicyFilter());};








StorageUtil.performStorageOperation = function StorageUtil_performStorageOperation__1(storageOperation, _) { var service, operation, definedParameterCount, operationArgs, result, __arguments = arguments; var __frame = { name: "StorageUtil_performStorageOperation__1", line: 152 }; return __func(_, this, arguments, StorageUtil_performStorageOperation__1, 1, __frame, function __$StorageUtil_performStorageOperation__1() {
    if ((storageOperation === null)) { return _(null); } ;
    service = storageOperation.service;
    if (!service) {
      return _(new Error("Service client can't be null")); } ;

    operation = (storageOperation.operation || "");

    if ((!service[operation] || !isFunction(service[operation]))) {
      return _(("Invalid operation " + operation)); } ;



    definedParameterCount = 2;
    operationArgs = Array.prototype.slice.call(__arguments).slice(definedParameterCount, __arguments.length);

    result = null; return (function ___(__then) { (function ___(_) { __tryCatch(_, function __$StorageUtil_performStorageOperation__1() {

          return restFunnel(__cb(_, __frame, 18, 4, __then, true), function __1(_) { var __frame = { name: "__1", line: 170 }; return __func(_, this, arguments, __1, 0, __frame, function __$__1() {

              return service[operation].apply_(__cb(_, __frame, 2, 15, function ___(__0, __1) { result = __1; _(); }, true), service, operationArgs); }); }); }); })(function ___(e, __result) { __tryCatch(_, function __$StorageUtil_performStorageOperation__1() { if (e) {



            StorageUtil.endProgress();
            return _(e); } else { _(null, __result); } ; }); }); })(function ___() { __tryCatch(_, function __$StorageUtil_performStorageOperation__1() {

        return _(null, result); }); }); });};





StorageUtil.startProgress = function(tips) {
  if ((progress !== null)) {
    StorageUtil.endProgress(); };

  progress = cli.interaction.progress(tips);};





StorageUtil.endProgress = function() {
  if ((progress !== null)) {
    progress.end(); };

  progress = null;};





StorageUtil.setOperationTimeout = function(options) {
  if (((((options.timeoutintervalInMs === undefined) && (operationTimeout !== null)) && !isNaN(operationTimeout)) && (operationTimeout > 0))) {

    options.timeoutIntervalInMs = operationTimeout; };};






StorageUtil.stringToContainerAccessLevel = function(str) {
  var accessType = BlobConstants.BlobContainerPublicAccessType;
  var accessLevel = accessType.OFF;
  if (str) {
    str = str.toLowerCase();
    switch (str) {
    case "blob": accessLevel = accessType.BLOB;
      break;
    case "container":
      accessLevel = accessType.CONTAINER;
      break;
    case "off":
      accessLevel = accessType.OFF;
      break;
      default:
      if (str) {
        throw new Error(util.format("Invalid container public access level %s", str));
      } ; break;

    }; };


  return accessLevel;};





StorageUtil.convertFileNameToBlobName = function(name) {
  return name.replace(/\\/gim, "/");};





StorageUtil.containerAccessLevelToString = function(accessType) {
  var publicAccessType = BlobConstants.BlobContainerPublicAccessType;
  var str = "Off";
  switch (accessType) {
  case publicAccessType.BLOB: str = "Blob";
    break;
  case publicAccessType.CONTAINER:
    str = "Container";
    break;
  case publicAccessType.OFF:
    str = "Off";
    break;
    default:
    if (accessType) {
      throw new Error(util.format("Invalid Container public access type %s", accessType));
    } ; break;

  };

  return str;};





StorageUtil.parseKvParameter = function(str) {
  if (str) {
    return connectionStringParser.parse(str); };};






StorageUtil.isNotFoundException = function(e) {
  return (e.code == "NotFound");};





StorageUtil.recursiveMkdir = function(root, specifiedPath) {
  if (utils.isWindows()) {

    specifiedPath = specifiedPath.replace(/\//g, "\\"); };

  var dirs = specifiedPath.split(path.sep);
  var dirPath = (root || "");
  var dirName = "";
  for (var i = 0; (i < dirs.length); i++) {
    dirName = utils.escapeFilePath(dirs[i]);
    dirPath = path.join(dirPath, dirName);
    if (!StorageUtil.doesPathExist(dirPath)) {
      fs.mkdirSync(dirPath); } ; };


  return dirPath;};


StorageUtil.doesPathExist = function(dirPath) {
  var existFunc = (fs.existsSync || path.existsSync);
  if (path) {
    return existFunc(dirPath); };

  return true;};





StorageUtil.getStructureFromBlobName = function(blobName) {
  var structure = { fileName: undefined, dirName: undefined };
  if ((blobName[(blobName.length - 1)] === "/")) {
    var lastIndex = blobName.lastIndexOf("/", (blobName.length - 2));
    structure.fileName = blobName.substr((lastIndex + 1));
    structure.dirName = blobName.substr(0, lastIndex); }
   else {
    structure.fileName = path.basename(blobName);
    structure.dirName = path.dirname(blobName); };

  return structure;};





StorageUtil.calculateFileMd5 = function(path, cb) {
  var stream = fs.createReadStream(path);
  var digest = crypto.createHash("md5");
  stream.on("data", function(d) { digest.update(d); });
  stream.on("end", function() {
    var md5 = digest.digest("base64");
    cb(null, md5); });};






StorageUtil.formatBlobProperties = function(properties, target) {
  if (!properties) { return };
  var propertyNames = ["contentType","contentEncoding","contentLanguage","cacheControl",];
  var postfix = "Header";
  var getPropertyIndex = function(key) {
    for (var i = 0; (i < propertyNames.length); i++) {
      if ((propertyNames[i].toLowerCase() == key.toLowerCase())) {
        return i; } ; };


    return -1; };


  var index = -1;
  for (var item in properties) {
    index = getPropertyIndex(item);
    if ((index == -1)) {
      throw new Error(util.format("Invalid value: %s. Options are: %s.", item, propertyNames)); } ;

    target[(propertyNames[index] + postfix)] = properties[item];
    if ((item.toLowerCase() === "contenttype")) {
      target["contentType"] = properties[item]; } ; };};









function isFunction(func) {
  return (typeof func === "function");};







function getStorageServiceSettings(connectionString) {
  if (!connectionString) {
    connectionString = process.env[StorageUtil.ENV_CONNECTIONSTRING_NAME]; };

  if (!connectionString) {
    if ((!process.env[StorageUtil.ENV_SDK_ACCOUNT_NAME] || !process.env[StorageUtil.ENV_SDK_ACCOUNT_KEY])) {
      throw new Error("Please set the storage account parameters or one of the following two environment variables to use storage command. 1.AZURE_STORAGE_CONNECTION_STRING, 2. AZURE_STORAGE_ACCOUNT and AZURE_STORAGE_ACCESS_KEY"); } ;

    return null; }
   else {
    return StorageServiceSettings.createFromConnectionString(connectionString); };};






function getRestOperationTimeout(cfg) {
  var radix = 10;
  var definedTimeout = parseInt(cfg[StorageUtil.OPERATION_TIMEOUT_CONFIG_KEY_NAME], radix);
  if ((isNaN(definedTimeout) || (definedTimeout <= 0))) {
    return null; }
   else {
    return definedTimeout; };};






function getRestConcurrency(cfg) {
  var radix = 10;
  var definedConcurrency = parseInt(cfg[StorageUtil.CONCURRENTCY_CONFIG_KEY_NAME], radix);
  if ((isNaN(definedConcurrency) || (definedConcurrency === 0))) {
    return getDefaultRestConcurrency(); }
   else {
    return definedConcurrency; };};






function getDefaultRestConcurrency() {
  var cpuCount = os.cpus().length;

  var asyncTasksPerCoreMultiplier = 1;
  return (cpuCount * asyncTasksPerCoreMultiplier);};


module.exports = StorageUtil;