{"mode":"editor","version":1,"windowDimensions":{"x":0,"y":22,"width":1440,"height":874},"syntax":{"deserializer":"Syntax","grammarOverridesByPath":{}},"project":{"path":"/Users/zeke/code/mapbox/api-maps","buffers":[{"text":"console.log(\"\\n\\ntile.js\")\n\nvar _ = require('underscore');\nvar express = require('express');\nvar config = require('../lib/config');\nvar Step = require('step');\nvar tilelive = require('tilelive');\nvar Vector = require('tilelive-vector');\nvar tools = require('../lib/tools');\nvar fs = require('fs');\nvar path = require('path');\nvar url = require('url');\nvar util = require('util');\nvar connectUtils = require('connect').utils;\nvar Blended = require('../lib/blended');\nvar Marker = require('../lib/marker');\nvar AWS = require('aws-sdk');\nvar HttpAgent = require('agentkeepalive');\nvar templates = require('../lib/templates');\nvar env = process.env.NODE_ENV || 'development';\nvar crypto = require('crypto');\nvar tokml = require('tokml');\nvar assert = require('assert');\nvar users = require('../lib/users');\nvar markers = require('../lib/markers');\nvar queue = require('queue-async');\nvar maps = require('../lib/maps');\nvar sortKeys = require('../lib/tilejson-util').sortKeys;\nvar toPublic = require('../lib/tilejson-util').toPublic;\nvar toPrivate = require('../lib/tilejson-util').toPrivate;\nvar streetlevel = require('../lib/tilejson-util').streetlevel;\nvar ErrorHTTP = require('../lib/errorhttp');\n\nvar agent = new HttpAgent({\n    maxSockets: 128,\n    maxKeepAliveRequests: 0,\n    maxKeepAliveTime: 30000\n});\n\n// Disable subversive 200 => 304 handling in Express.\nexpress.request.__defineGetter__('fresh', function() { return false; });\n\n// Copy + paste job from Express /lib/response.js.\n// Alters cb && cb() output back to straight cb() format.\nexpress.response.jsonp = function(obj){\n  // allow status / body\n  if (2 == arguments.length) {\n    // res.json(body, status) backwards compat\n    if ('number' == typeof arguments[1]) {\n      this.statusCode = arguments[1];\n    } else {\n      this.statusCode = obj;\n      obj = arguments[1];\n    }\n  }\n\n  // settings\n  var app = this.app;\n  var replacer = app.get('json replacer');\n  var spaces = app.get('json spaces');\n  var body = JSON.stringify(obj, replacer, spaces)\n    .replace(/\\u2028/g, '\\\\u2028')\n    .replace(/\\u2029/g, '\\\\u2029');\n  var callback = this.req.query[app.get('jsonp callback name')];\n\n  // content-type\n  this.charset = this.charset || 'utf-8';\n  this.set('Content-Type', 'application/json');\n\n  // jsonp\n  if (callback) {\n    if (callback instanceof Array) callback = callback[0];\n    this.set('Content-Type', 'text/javascript');\n    var cb = callback.replace(/[^\\[\\]\\w$.]/g, '');\n    // body = cb + ' && ' + cb + '(' + body + ');';\n    body = cb + '(' + body + ');';\n  }\n\n  return this.send(body);\n};\n\n// HTML sanitizer.\nvar sanitize = function(o) {\n    var html_sanitize = require('sanitizer').sanitize;\n    return html_sanitize(o,\n        function(url) { if (/^(https?:\\/\\/|data:image)/.test(url)) return url; },\n        function(x) { return x; });\n};\n\nvar server = module.exports = express();\n\nserver.port = config.tilePort;\n\nif (process.env.NODE_ENV != 'test') {\n    server.use(express.logger({\n        format: '[:date] [info] [http] \":method :url HTTP/:http-version\" :status :res[content-length] \":referrer\" \":user-agent\" \":req[x-amz-cf-id]\" :response-time ms',\n        buffer: 1000\n    }));\n}\n\nserver.param('json', function(req, res, next, param) {\n    if (param === 'jsonp') {\n        req.query.callback = req.query.callback || 'grid';\n    }\n    next();\n});\nserver.param('version', function(req, res, next, id) {\n    // The version param being present is an indication of a good\n    // request to the API. Set CORS, CloudFront TTL headers.\n    res.set('Cache-Control', 'max-age=3600');\n    res.set('Access-Control-Allow-Origin', '*');\n    res.set('Access-Control-Allow-Methods', 'GET');\n\n    var v = parseInt(id, 10);\n    if (_(config.versions).include(v)) {\n        req.query.version = v;\n        next();\n    } else {\n        next(new ErrorHTTP(404));\n    }\n});\nserver.param('account', function(req, res, next, id) {\n    req.query.account = id;\n    next();\n});\nserver.param('tilesets', blended, user);\nserver.param('accountMap', accountMap);\nserver.param('marker', marker);\nserver.param('query', carmen);\n\n// SSL + hosts middleware.\nserver.use(function(req, res, next) {\n    req.query.hosts = {\n        uiHost: config.uiHost,\n        tileHost: config.tileHost\n    };\n\n    if (req.query.secure !== undefined) {\n        _(req.query.hosts).each(function(v, k) {\n            if (Array.isArray(v)) {\n                // Create a fresh instance of the array so that we do not\n                // modify our config.\n                req.query.hosts[k] = [];\n                v.forEach(function(val, i) {\n                    req.query.hosts[k][i] = val.replace(/^http:/,'https:');\n                });\n            }\n            else {\n                req.query.hosts[k] = v.replace(/^http:/,'https:');\n            }\n        });\n    }\n\n    next();\n});\n\n// status monitoring endpoint\nserver.get('/status/:environment', status);\n\n// Provide upload credentials to applications like tilemill.\n// Use hash to bypass the CDN.\nserver.get('/v:version(\\\\d)/:hash([0-9a-z]{6})/upload.:json(json(p?))', upload);\n\n// tilesets, maps, albums endpoints\nserver.get('/v:version(\\\\d)/albums.:json(json(p?))', albums);\nserver.get('/v:version(\\\\d)/:account/:type(maps|tilesets).:json(json(p?))', mapsTileJSON);\n\n// maps gallery\nserver.get('/v:version(\\\\d)/:account/:accountmaps(maps).html', mapsHTML);\n\n// tilejson, markers, tile, grid, download, embed, static, thumb endpoints.\nserver.get('/v:version(\\\\d)/:tilesets/:z(\\\\d+)/:x(\\\\d+)/:y(\\\\d+):retina(@2x)?.:format(png|jpg):quality(\\\\d{0,3})',\n    [locked, conditional, tiles]);\nserver.get('/v:version(\\\\d)/:tilesets/:z(\\\\d+)/:x(\\\\d+)/:y(\\\\d+).:format(vector.pbf)',\n    [locked, conditional, tiles]);\nserver.get('/v:version(\\\\d)/:tilesets/:z(\\\\d+)/:x(\\\\d+)/:y(\\\\d+).:format(grid).:json(json)',\n    [locked, conditional, tiles]);\nserver.get('/v:version(\\\\d)/:mbtiles.mbtiles',\n    [conditional, download]);\nserver.get('/v:version(\\\\d)/:tilesets.:json(json(p?))',\n    [conditional, tilejson]);\nserver.get('/v:version(\\\\d)/:tilesets/markers.geo:json(json(p?))',\n    [locked, conditional, markerData]);\nserver.get('/v:version(\\\\d)/:tilesets/markers.kml',\n    [locked, conditional, markerDataKML]);\nserver.get('/v:version(\\\\d)/:tilesets/:api(g|mm)/:options?.:format(html)', locked, embedHTML);\nserver.get('/v:version(\\\\d)/:tilesets/:api(page).:format(html)', locked, embedHTML);\nserver.get('/v:version(\\\\d)/:tilesets/:options?.:format(html)', locked, embedHTML);\n// for now static requests do not support conditional GETs.\n// @TODO once mapnik-based compositing is unlocked, reimplement\n// conditional GETs for static.\nserver.get('/v:version(\\\\d)/:tilesets/:markers?/:x,:y,:z/:w(\\\\d+)x:h(\\\\d+):retina(@2x)?.:format(png|jpg):quality(\\\\d{0,3})',\n    [locked, loadMarkers, staticTile]);\nserver.get('/v:version(\\\\d)/:accountMap([^.]+)/thumb:retina(@2x)?.:format(png|jpg):quality(\\\\d{0,3})',\n    [locked, loadMarkers, thumb, staticTile]);\nserver.get('/v:version(\\\\d)/:tilesets/thumb:retina(@2x)?.:format(png|jpg):quality(\\\\d{0,3})',\n    [locked, loadMarkers, thumb, staticTile]);\n\n// marker image endpoint.\nserver.get('/v:version(\\\\d)/marker/:marker:retina(@2x)?.png:quality(\\\\d{0,3})',\n    [conditional, markerImage]);\n\n// geocoding.\nserver.get('/v:version(\\\\d)/:tilesets/geocode/:query.:json(json(p?))', locked, geocode);\n\nserver.get('/robots.txt', robots);\nserver.get('/crossdomain.xml', crossdomainXML);\n\nserver.use(require('./legacy'));\nserver.use(require('./error').notFound);\nserver.use(require('./error').showError);\n\nfunction crossdomainXML(req, res, next) {\n    res.send(templates.CrossdomainXML(), {\n        'Content-Type': 'text/x-cross-domain-policy'\n    }, 200);\n}\n\nfunction albums(req, res, next) {\n    var q = queue();\n    _(['mapbox', 'fcc', 'foo', 'admin', 'test2', 'slate', 'energy', 'nps']).each(function(id) {\n        q.defer(function(id, callback) {\n            users.read(id, function(err, user) {\n                if (err && err.status === 404) return callback();\n                if (err) return callback(err);\n                user = _(user).pick([\n                    'accountLevel',\n                    'description',\n                    'id',\n                    'name',\n                    'website'\n                ]);\n                var opts = {};\n                opts.status = 'available';\n                opts.account = user.id;\n                opts.raw = true;\n                for (var k in req.query) opts[k] = opts[k] || req.query[k];\n                loadmaps(opts, function(err, resp) {\n                    if (err) return callback(err);\n                    resp = resp.map(function(m) {\n                        return toPrivate(m, req.query.version, req.query.hosts.tileHost);\n                    });\n                    if (req.query.version === 1)\n                        user.quota = { count: resp.length };\n                    user.mapCount = resp.length;\n                    user.thumbs = _(resp).chain()\n                        .map(function(m) {\n                            return req.query.hosts.tileHost[0] + '/v' + req.query.version + '/' + m.id + '/thumb.png'\n                        })\n                        .value()\n                        .slice(0,4);\n                    callback(null, user);\n                });\n            });\n        }, id);\n    });\n    q.awaitAll(function(err, results) {\n        if (err) return next(err);\n        res.jsonp(_(results).compact());\n    });\n}\n\nfunction loadmaps(options, callback) {\n    maps.list(options, function(err, maps) {\n        if (err) return callback(err);\n        if (!maps.length) return callback(null, []);\n        var tilejsons = new Array(maps.length);\n        tilejsons.counter = 0;\n        maps.forEach(function(doc, i) {\n            new Blended({ protocol: 'mapbox:', pathname: doc.id, doc: doc }, function(err, blended) {\n                tilejsons.err = tilejsons.err || err;\n                if (blended) return blended.getInfo(function(err, tilejson) {\n                    tilejsons.err = tilejsons.err || err;\n                    if (tilejson && options.raw) {\n                        tilejsons[i] = tilejson;\n                    } else if (tilejson) {\n                        tilejsons[i] = toPublic(tilejson, options.version, options.hosts.tileHost);\n                    }\n                    done();\n                }, options);\n                done();\n            });\n        });\n        function done() {\n            if (++tilejsons.counter < maps.length) return;\n            if (tilejsons.err) return callback(err);\n            callback(null, tilejsons);\n        }\n    });\n}\n\nfunction mapsTileJSON(req, res, next) {\n    req.query.status = 'available';\n    if (req.params.type === 'tilesets') req.query._type = 'tileset';\n    loadmaps(req.query, function(err, maps) {\n        if (err) return next(err);\n        res.jsonp(maps);\n    });\n}\n\nfunction mapsHTML(req, res, next) {\n    req.query.status = 'available';\n    users.read(req.query.account, function(err, user) {\n        if (err && err.status == 404) return next(new ErrorHTTP(404));\n        if (err) return next(err);\n        loadmaps(req.query, function(err, maps) {\n            if (err) return next(err);\n            res.send(templates.Maps({\n                config: config,\n                account: user,\n                version: req.query.version,\n                maps: maps\n            }));\n        });\n    });\n}\n\n// MBTiles download.\n// @TODO: Current `maxAge` option is hardcoded into place. Find better\n// way to pass this through.\nfunction download(req, res, next) {\n    maps.read(req.param('mbtiles'), function(err, data) {\n        if (err) return next(err);\n        if (!data.metadata || !data.metadata.download) {\n            return next(new ErrorHTTP(\"Tileset can't be downloaded\", 404));\n        }\n\n        var uri = url.parse(data.metadata.download);\n        var bucket = (uri.host||'').split('.').shift();\n        if (bucket && uri.pathname) {\n            // The files are public but we need to use signed urls to in\n            // order to set `response-content-disposition`. See #2275.\n            var s3 = new AWS.S3({\n                accessKeyId: config.awsKey,\n                secretAccessKey: config.awsSecret,\n            });\n            s3.getSignedUrl('getObject', {\n                Bucket: bucket,\n                Key: uri.pathname.substr(1),\n                Expires:  86400,\n                ResponseContentDisposition: 'attachment;filename=' + req.param('mbtiles').split('.').pop() + '.mbtiles',\n            }, function(err, url) {\n                if (err) return next(err);\n                return res.redirect(url);\n            });\n        } else {\n            next(new ErrorHTTP(\"Tileset can't be downloaded\", 404));\n        }\n    });\n}\n\nfunction blended(req, res, next, id) {\n\n    console.log(\"\\n\\nblended\\n\\n\")\n\n    var tilesets = _((id || req.params.tilesets || '').split(',')).compact();\n    if (tilesets.length > 15) return next(new ErrorHTTP('Too many tilesets (max: 15).', 400));\n\n    req.blendedParams = {\n        scale: req.params.retina === '@2x' ? 2 : undefined,\n        format: req.params.format,\n        quality: req.params.quality,\n        hasMarkers: req.params.w ? 1 : 0,\n        version: req.query.version,\n        hosts: req.query.hosts\n    };\n\n    new Blended('mapbox:///' + tilesets.join(',') + '?cache=1', function(err, b) {\n        if (err && err.message === 'Invalid tilesource protocol')\n            return next(new ErrorHTTP(400));\n        if (err && err.message === 'Tileset does not exist' && req.query.newmap)\n            return blended(req, res, next, maps.presetlayers(req.query));\n        if (err)\n            return next(err);\n\n        if (req.params.format && !b.enabled(req.params.format)) {\n            console.log(\"\\n\\n\", 'req.params.format', req.params.format, \"\\n\\n\")\n            return next(new ErrorHTTP(400));\n        }\n\n        req.blended = b;\n\n        console.log(\"\\n\\nwhat's next?\")\n        console.log(next)\n        return next();\n    });\n}\n\n// Deny access to locked sources unless they have a cookie and/or\n// security querystring (only allowed on json* endpoints by CloudFront).\nfunction locked(req, res, next) {\n\n    console.log(\"\\n\\nlocked\\n\\n\")\n\n    // Determines if the user needs session-based access\n    // to API SSL tiles and tinting.\n    if (req.headers['x-encrypted'] === 'yes') {\n        // This is required for Connect to send out secure cookies.\n        req.connection.proxySecure = true;\n        // Any SSL requests without these cookies 400.\n        if (!(/connect\\.sid/).test(req.headers.cookie||'')) {\n            return next(new ErrorHTTP(400));\n        }\n    }\n\n    var access = !req.blended.locked;\n    access = access || /connect\\.sid|bones\\.auth/.test(req.headers.cookie||'');\n    access = access || req.query._ === '1';\n    return !access ? next(new ErrorHTTP(400)) : next();\n}\n\nfunction user(req, res, next, id) {\n    // Skip check for account over limit for user who is logged in (e.g.\n    // requesting her own tiles over SSL API).\n    if (req.connection.proxySecure) return next();\n\n    // Pass if we can't load the user.\n    if (!req.blended.account)\n        return next();\n    if (req.blended.account.destroyed)\n        return next(new ErrorHTTP('Account deleted.', 404));\n    if (req.blended.account.disabled)\n        return next(new ErrorHTTP('Account over limit.', 404));\n\n    next();\n}\n\nfunction conditional(req, res, next) {\n\n    console.log(\"\\n\\nconditional\\n\\n\")\n\n    // Return a 304 if not modified based on blended.mtime\n    // without loading tiles or grids. We must .toString()\n    // the mtime to ensure we have the same date granularity\n    // as the original request.\n    var resource = req.blended || req.params.marker;\n\n    // Not conditional.\n    if (!connectUtils.conditionalGET(req)) return next();\n\n    // Content has been modified.\n    if (connectUtils.modified(req, res, { 'last-modified':resource.mtime.toString() })) return next();\n\n    res.set('Cache-Control', 'max-age=' + resource.maxAge);\n\n    // If this is a tile request (presence of 'format' in params)\n    // a per-tile check can now be performed leading to either a 304 response\n    // (individual tile has not been updated) or 200.\n    if (req.params.format) {\n        var z = req.param('z');\n        var x = req.param('x');\n        var y = req.param('y');\n        return req.blended.getHeaders(z, x, y, function(err, headers) {\n            if (err) return next(err);\n            if (connectUtils.modified(req, res, { 'last-modified':headers['Last-Modified'] })) {\n                return next();\n            } else {\n                return connectUtils.notModified(res);\n            }\n        }, req.blendedParams);\n    } else {\n        return connectUtils.notModified(res);\n    }\n}\n\nfunction tiles(req, res, next) {\n    var method = 'getTile';\n    var z = req.param('z');\n    var x = req.param('x');\n    var y = req.param('y');\n\n    // v1  incoming request TMS => tilesource XYZ\n    // v2+ incoming request XYZ => tilesource XYZ\n    if (req.query.version === 1) y = Math.pow(2, z) - 1 - y;\n\n    if (req.params.format === 'grid') {\n        method = 'getGrid';\n        res.charset = 'utf-8'; // Don't re-encode JSON output.\n        req.query.callback = req.query.callback || 'grid';\n\n        // Block UTFgrid requests for evernote's geocoding map.\n        // See https://github.com/mapbox/business/issues/495\n        var tilesets = req.params.tilesets.split(',');\n        if (_.intersection(tilesets, ['evnote.en-custom-city', 'evnote.map-vvq35jir']).length) {\n            return next(new ErrorHTTP('Grid does not exist', 404));\n        }\n    }\n\n    req.blended[method](z, x, y, function(err, buffers, headers) {\n        if (err) return next(err);\n\n        _(headers).each(function(v, k) {\n            res.set(k, v);\n        });\n\n        if (req.params.format === 'grid') {\n            res.jsonp(buffers);\n        } else {\n            res.send(buffers);\n        }\n    }, req.blendedParams);\n}\n\nfunction loadMarkers(req, res, next) {\n    var matchURL = /^(url)(?:-([^\\(]+))()\\((-?\\d+(?:.\\d+)?),(-?\\d+(?:.\\d+)?)/;\n    var matchFile = /^(pin-s|pin-m|pin-l)(?:-([a-z0-9-]+))?(?:\\+([0-9a-fA-F]{3}|[0-9a-fA-F]{6}))?\\((-?\\d+(?:.\\d+)?),(-?\\d+(?:.\\d+)?)/;\n    // Load markers for tilesets and prefix req.params.markers\n    // with the native map markers.\n    Step(function() {\n        if (req.blended.markers) return this();\n        var group = this.group();\n        _(req.params.tilesets.split(',')).each(function(tileset) {\n            var next = group();\n            markers.read(tileset, function(err, data) {\n                if (err && err.status === 400) return next();\n                if (err && err.status === 404) return next();\n                if (err) return next(err);\n                return next(null, data.features);\n            });\n        });\n    }, function(err, markers) {\n        if (err) throw err;\n        req.blended.markers = req.blended.markers || _(markers).chain()\n            .compact()\n            .flatten()\n            .sortBy(function(f) { return -1 * f.geometry.coordinates[1]; })\n            .filter(function(f) {\n                if (isNaN(parseFloat(f.geometry.coordinates[0]))) return false;\n                if (isNaN(parseFloat(f.geometry.coordinates[1]))) return false;\n                return true;\n            })\n            .map(function(f) {\n                return _('pin-<%=s%><%=i%>+<%=c%>(<%=x%>,<%=y%>)').template({\n                    s:(f.properties['marker-size'] || 'medium').charAt(0),\n                    i:(f.properties['marker-symbol'] ? '-' + f.properties['marker-symbol'] : ''),\n                    c:(f.properties['marker-color'] || '7e7e7e').replace('#',''),\n                    x:parseFloat(f.geometry.coordinates[0]),\n                    y:parseFloat(f.geometry.coordinates[1])\n                });\n            }).value();\n        req.params.markers = req.params.markers ?\n            req.blended.markers.concat(req.params.markers).join(',') :\n            req.blended.markers.join(',');\n        this();\n    // Load markers from marker url params.\n    }, function(err) {\n        if (err) throw err;\n        if (!req.params.markers) return this(null, []);\n        var group = this.group();\n        var id = req.params.markers;\n        _(id.split('),')).forEach(function(marker) {\n            var next = group();\n            var isurl = marker.indexOf('url-') === 0;\n            marker = marker.match(isurl ? matchURL : matchFile);\n            if (!marker) return next(new ErrorHTTP('Marker \"' + id + '\" is invalid.', 400));\n            new Marker({\n                name: marker[1],\n                label: marker[2],\n                tint: marker[3],\n                lon: parseFloat(marker[4]),\n                lat: parseFloat(marker[5]),\n                retina: req.params.retina === '@2x'\n            }, next);\n            id = id.substring(marker[0].length);\n        });\n    }, function(err, markers) {\n        if (err) return next(err);\n        req.params.markers = markers;\n        next();\n    });\n}\n\nfunction staticTile(req, res, next) {\n\n    console.log(\"\\n\\nstaticTile\\n\\n\")\n    console.log(req.params)\n\n    var w = parseInt(req.params.w, 10);\n    var h = parseInt(req.params.h, 10);\n    var z = parseInt(req.params.z, 10);\n    var x = parseFloat(req.params.x);\n    var y = parseFloat(req.params.y);\n    var markers = req.params.markers || [];\n    // Double dimmensions and increase zoom level for retina requests.\n    // Output image is still limited to 1280x1280.\n    if (req.params.retina) {\n        w = w * 2;\n        h = h * 2;\n        z++;\n    }\n    if (w <= 0 || w > 1280)\n        return next(new ErrorHTTP('Invalid width.', 400));\n    if (h <= 0 || h > 1280)\n        return next(new ErrorHTTP('Invalid height.', 400));\n    if (Math.abs(x) > 180)\n        return next(new ErrorHTTP('Invalid longitude.', 400));\n    if (Math.abs(y) > 85.0511)\n        return next(new ErrorHTTP('Invalid latitude.', 400));\n    if (z < 0 || z > 22)\n        return next(new ErrorHTTP('Invalid zoom level.', 400));\n    req.blended.getStatic(z, x, y, w, h, markers, function(err, buffers, headers) {\n        console.log(\"getStatic fail\", err)\n        if (err) return next(err);\n        _(headers).each(function(v, k) {\n            res.set(k, v);\n        });\n        res.send(buffers);\n    }, req.blendedParams);\n}\n\nfunction marker(req, res, next, id) {\n    var matchFile = /^(pin-s|pin-m|pin-l)(?:-([a-z0-9-]+))?(?:\\+([0-9a-fA-F]{6}|[0-9a-fA-F]{3}))?$/;\n    var marker = id.match(matchFile);\n    if (!marker) return next(new ErrorHTTP('Marker \"' + id + '\" is invalid.', 400));\n    new Marker({\n        name: marker[1],\n        label: marker[2],\n        tint: marker[3],\n        retina: req.params.retina === '@2x'\n    }, function(err, marker) {\n        if (err) return next(err);\n        req.params.marker = marker;\n        next();\n    });\n}\n\nfunction markerImage(req, res, next) {\n    var marker = req.params.marker;\n    if (marker) {\n        var headers = {\n            'Content-Type': 'image/png',\n            'Last-Modified': new Date(marker.mtime).toUTCString(),\n            'ETag': marker.size + '-' + Number(marker.mtime),\n            'Cache-Control': 'max-age=' + marker.maxAge\n        };\n        _(headers).each(function(v, k) {\n            res.set(k, v);\n        });\n        res.send(marker.image);\n    } else {\n        next();\n    }\n}\n\nfunction tilejson(req, res, next) {\n    req.blended.getInfo(function(err, info) {\n        if (err) return next(err);\n        _(req.blended.headers()).each(function(v, k) {\n            res.set(k, v);\n        });\n        res.jsonp(toPublic(info, req.query.version, req.query.hosts.tileHost));\n    }, req.blendedParams);\n}\n\nfunction markerData(req, res, next) {\n    markers.read(req.params.tilesets, function(err, resp) {\n        if (err && err.status === 400) {\n            return next(new ErrorHTTP('Markers do not exist', 404));\n        } else if (err && err.status === 404) {\n            return next(new ErrorHTTP('Markers do not exist', 404));\n        } else if (err) {\n            return next(err);\n        }\n        _(req.blended.headers()).each(function(v, k) {\n            res.set(k, v);\n        });\n        // Set ttl to 5 mins\n        res.set('Cache-Control', 'max-age=300');\n        delete resp._id;\n        delete resp._rev;\n        resp.type = 'FeatureCollection';\n        res.jsonp(sortKeys(resp));\n    });\n}\n\nfunction markerDataKML(req, res, next) {\n    markers.read(req.params.tilesets, function(err, resp) {\n        if (err && err.status === 400) {\n            return next(new ErrorHTTP('Markers do not exist', 404));\n        } else if (err && err.status === 404) {\n            return next(new ErrorHTTP('Markers do not exist', 404));\n        } else if (err) {\n            return next(err);\n        }\n        var kml = tokml({\n            type: 'FeatureCollection',\n            features: resp.features\n        }, {\n            name: 'title',\n            description: 'description',\n            simplestyle: true\n        });\n        _(req.blended.headers()).each(function(v, k) {\n            res.set(k, v);\n        });\n        res.set('Content-Type', 'application/vnd.google-earth.kml+xml');\n        // Set ttl to 5 mins\n        res.set('Cache-Control', 'max-age=300');\n        res.send(kml);\n    });\n}\n\nfunction thumb(req, res, next) {\n\n    console.log(\"\\n\\nthumb\\n\\n\")\n\n    req.blended.getInfo(function(err, info) {\n        if (err) return next(err);\n        try {\n            var center = info.center;\n            req.params.x = center[0];\n            req.params.y = center[1];\n            req.params.z = Math.round(center[2]);\n            req.params.w = 256;\n            req.params.h = 256;\n        } catch(e) {\n            return next(ErrorHTTP(500));\n        }\n        return next();\n    }, req.blendedParams);\n}\n\nfunction embedHTML(req, res, next) {\n    req.blended.getInfo(function(err, info) {\n        if (err) return next(err);\n\n        info = info || {};\n        info.api = req.params.api || info.api || 'mm';\n        info.options = req.params.options ?\n            req.params.options.split(',') :\n            (info.options || ['attribution','geocoder','legend','share','zoompan','zoomwheel']);\n        info.center = info.center || [0, 0, 0];\n\n        if (info.api !== 'mm' && info.api !== 'g' && info.api !== 'page')\n            return next(new ErrorHTTP(404));\n\n        // Page template disallows multiple tilesets (for now).\n        if (info.api === 'page' && req.params.tilesets.indexOf(',') !== -1)\n            return next(new ErrorHTTP(404));\n\n        // Disallow invalid options.\n        if (maps.validateKey(null, 'options', info.options))\n            return next(new ErrorHTTP(404));\n\n        // Disallow page for maps without owners.\n        if (!req.blended.account) return next(new ErrorHTTP(404));\n\n        var template = (info.api === 'page' ? 'EmbedPage' : 'EmbedAPI');\n        _(req.blended.headers()).each(function(v, k) {\n            res.set(k, v);\n        });\n\n        // Streetlevel hack.\n        streetlevel(info);\n\n        try {\n            res.send(templates[template]({\n                config: config,\n                version: req.query.version,\n                publicjson: toPublic(info, req.query.version, req.query.hosts.tileHost),\n                tilejson: info,\n                account: req.blended.account,\n                sanitize: sanitize,\n                tools: tools\n            }));\n        } catch(e) {\n            next(e);\n        }\n    }, req.blendedParams);\n}\n\nfunction upload(req, res, next) {\n    res.jsonp(tools.uploadParams({\n        id: tools.randomHexCode(32),\n        account: 'upload',\n        host: config.uiHost,\n        bucket: config.tilesetsBucket,\n        awsKey: config.awsKey,\n        awsSecret: config.awsSecret,\n        expiration: 60e3\n    }));\n}\n\n// Load the \"primary\" map associated with an account.\nfunction accountMap(req, res, next, id) {\n    if (id.indexOf('.') > 0) return next();\n    req.query.account = id;\n    req.query.ids = true;\n    req.query.status = 'available';\n    maps.list(req.query, function(err, maps) {\n        if (maps.length) {\n            req.params.tilesets = maps[0].id;\n            blended(req, res, next, maps[0].id);\n        } else {\n            next(new ErrorHTTP(404));\n        }\n    });\n}\n\nfunction robots(req, res, next) {\n    res.send(templates.Robots({\n        dev: true\n    }));\n}\n\nfunction carmen(req, res, next) {\n    req.blended.getCarmen(function(err, carmen) {\n        if (err) return next(err);\n        req.carmen = carmen;\n        return next();\n    }, req.blendedParams);\n}\n\nfunction geocode(req, res, next) {\n    var query = req.param('query').split(';');\n    if (query.length > 50) return next(new ErrorHTTP(400));\n    Step(function() {\n        var group = this.group();\n        _(query).each(function(q) {\n            req.carmen.geocode(q, {stats:false}, group());\n        });\n    }, function(err, results) {\n        if (err) return next(err);\n        _(results).each(function(result, i) {\n            results[i].attribution = req.carmen.attribution;\n            results[i] = geocode.toLegacy(results[i]);\n        });\n        _(req.blended.headers()).each(function(v, k) {\n            res.set(k, v);\n        });\n        if (results.length == 1) res.jsonp(results.pop());\n        else res.jsonp(results);\n    });\n}\n\n// Legacy payload migration from geojson to previous carmen format.\ngeocode.toLegacy = function(result) {\n    var legacy = {};\n    legacy.query = result.query;\n    legacy.stats = result.stats;\n    legacy.attribution = {};\n    // Remap attribution.\n    for (var id in result.attribution) {\n        var key = id.replace(/^place$/, 'mapbox-places').replace(/^postcode$/, 'zipcode');\n        legacy.attribution[key] = result.attribution[id];\n    }\n    // Reverse.\n    if (typeof legacy.query[0] === 'number') {\n        legacy.results = [ result.features.reduce(function(memo, f) {\n            // Skip postcodes in context to match legacy setup.\n            if ((/^postcode\\./).test(f.id)) return memo;\n            memo.push(_({\n                id: f.id.replace(/^place\\./, 'mapbox-places.'),\n                bounds: f.bbox,\n                lon: f.center ? f.center[0] : undefined,\n                lat: f.center ? f.center[1] : undefined,\n                name: f.address ? f.address + ' ' + f.text : f.text,\n                type: f.properties.type || f.id.split('.')[0].replace(/^place$/, 'city'),\n            }).defaults(_(f.properties).omit('search','title')));\n            return memo;\n        }, []) ];\n    // Forward.\n    } else {\n        var relevance = result.features.length && result.features[0].relevance;\n        legacy.results = result.features\n            // Grab only features with top relevance.\n            .filter(function(f) { return relevance - f.relevance === 0 })\n            .map(function(f) {\n                var type = f.id.split('.')[0];\n                var res = [];\n                res.push(_({\n                    id: f.id\n                        .replace(/^place\\./, 'mapbox-places.')\n                        .replace(/^postcode\\./, 'zipcode.'),\n                    bounds: f.bbox,\n                    lon: f.center ? f.center[0] : undefined,\n                    lat: f.center ? f.center[1] : undefined,\n                    name: f.address ? f.address + ' ' + f.text : f.text,\n                    type: f.properties.type || f.id.split('.')[0]\n                        .replace(/^place$/, 'city')\n                        .replace(/^postcode$/, 'zipcode')\n                }).defaults(_(f.properties).omit('search','title')));\n                if (f.context) f.context.reduce(function(memo, f) {\n                    // Skip postcodes in context to match legacy setup.\n                    if ((/^postcode\\./).test(f.id)) return memo;\n                    memo.push({\n                        id: f.id.replace(/^place\\./, 'mapbox-places.'),\n                        name: f.text,\n                        type: f.id.split('.')[0].replace(/^place$/, 'city')\n                    });\n                    return memo;\n                }, res);\n                return res;\n            });\n    }\n    return legacy;\n};\n\n// Route for ELB health checks and Server Density uptime checks.\nfunction status(req, res, next) {\n    // Prevent instances from becoming healthy if they are accidentally placed\n    // into the wrong ELB by comparing actual and expected config values.\n    var assertion = req.param('environment') === 'production' ? assert.equal : assert.notEqual;\n    var err = tools.configCheck(assertion, config);\n    if (err) return next(err);\n\n    config.couch.app.db.get('', function(err) {\n        if (err) {\n            err.status = 500;\n            return next(err);\n        }\n        res.set('Content-Type', 'text/plain');\n        res.send('MapBox! Hotdogs!', 200);\n    });\n}\n","markers":{"markers":{"1":{"id":1,"range":[[0,0],[0,0]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":45},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"filePath":"/Users/zeke/code/mapbox/api-maps/servers/tile.js","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"4d1a44bf1880fcb4f1a935ba9fa35bb77051071e","deserializer":"TextBuffer"}],"deserializer":"Project"},"workspace":{"paneContainer":{"root":{"items":[{"id":45,"softTabs":true,"scrollTop":0,"scrollLeft":0,"displayBuffer":{"id":46,"softWrap":false,"editorWidthInChars":121,"tokenizedBuffer":{"bufferPath":"/Users/zeke/code/mapbox/api-maps/servers/tile.js","tabLength":4,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"}],"activeItemUri":"/Users/zeke/code/mapbox/api-maps/servers/tile.js","focused":false,"active":true,"deserializer":"Pane"},"deserializer":"PaneContainer"},"fullScreen":false,"deserializer":"Workspace"},"packageStates":{"fuzzy-finder":{"/Users/zeke/code/mapbox/api-maps/servers/tile.js":1397268356222},"keybinding-resolver":{"attached":false},"metrics":{"sessionLength":1389685},"tree-view":{"directoryExpansionStates":{"lib":{},"servers":{}},"selectedPath":"/Users/zeke/code/mapbox/api-maps/servers/tile.js","hasFocus":false,"attached":true,"scrollLeft":0,"scrollTop":173,"width":200},"find-and-replace":{"viewState":{"findHistory":["tilest","echo","png","locked","function tile","unction","function condit","function thumb","locked","wat","enabled","blended","b.enab","req.blended","b.enabled","blended","blended()",", blended","b.enable","paramCall","param","console.log","static","getStatic","source"],"replaceHistory":[],"modelState":{"useRegex":false,"inCurrentSelection":false,"caseSensitive":false}},"projectViewState":{"findHistory":["to use for webhoo","Invalidate JSON","Invalida JSON","Invalid JSON","Invalid JSON config file","settings.json",".get","express","v3","staticFile","pretend",".getTile"],"replaceHistory":[],"pathsHistory":[],"modelState":{"useRegex":false,"caseSensitive":false}},"resultsModelState":{"useRegex":false,"caseSensitive":false}}}}